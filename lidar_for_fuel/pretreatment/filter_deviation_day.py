"""
Keep points within deviation_day around the most frequent acquisition day.
"""
import json
from collections import defaultdict

import numpy as np
import pdal


def filter_points_by_date(input_pipeline: pdal.Pipeline, deviation_day: int) -> pdal.Pipeline:
    """
    Creates a PDAL pipeline to filter a LiDAR point cloud,
    keeping only acquisitions within the densest Â±x day window.

    Args:
        input_pipeline (pdal.Pipeline): Executed PDAL Pipeline object.
        deviation_day (int): Number of days around the main acquisition day.

    Returns:
        pdal.Pipeline: Configured PDAL pipeline for filtering points.
    """
    arrays = input_pipeline.arrays
    if len(arrays) == 0:
        raise ValueError("No arrays generated by the pipeline.")
    points = arrays[0]

    # Check for GpsTime field
    if "GpsTime" not in points.dtype.names:
        raise ValueError("Point cloud does not contain a 'GpsTime' field.")

    # Extract timestamps
    timestamps = points["GpsTime"]

    # Convert to days (Unix timestamp in seconds)
    days = np.floor(timestamps / (24 * 3600))

    # Count points per day
    day_counts = defaultdict(int)
    for day in days:
        day_counts[day] += 1

    # Find the day with the most points
    main_day = max(day_counts.items(), key=lambda x: x[1])[0]

    # Define the day window to keep
    min_day = main_day - deviation_day
    max_day = main_day + deviation_day

    # Create PDAL pipeline using range filter for timestamps
    filter_pipeline_json = {
        "pipeline": [{"type": "filters.range", "limits": f"GpsTime[{min_day*24*3600}:{max_day*24*3600}]"}]
    }

    # Return a PDAL Pipeline object
    return pdal.Pipeline(json.dumps(filter_pipeline_json), arrays=[points])
